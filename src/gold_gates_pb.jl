# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-09-11T13:18:49.219
# original file: /home/yuyichao/projects/euriqa/GoldGates.jl/pb/gold_gates.proto (proto3 syntax)

module gold_gates_pb

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export ParticipationFactor, XXSolution, SysMetadata, Modes, SystemParams, GateSolutionSet


struct ParticipationFactor
    factors::Vector{Float64}
end
ParticipationFactor(;factors = Vector{Float64}()) = ParticipationFactor(factors)
PB.default_values(::Type{ParticipationFactor}) = (;factors = Vector{Float64}())
PB.field_numbers(::Type{ParticipationFactor}) = (;factors = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ParticipationFactor})
    factors = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, factors)
        else
            PB.skip(d, wire_type)
        end
    end
    return ParticipationFactor(factors[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ParticipationFactor)
    initpos = position(e.io)
    !isempty(x.factors) && PB.encode(e, 1, x.factors)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ParticipationFactor)
    encoded_size = 0
    !isempty(x.factors) && (encoded_size += PB._encoded_size(x.factors, 1))
    return encoded_size
end

struct XXSolution
    nsteps::UInt32
    angle_sign::Int32
    time::Vector{Float64}
    phase::Vector{Float64}
    phase_slope::Vector{Float64}
    amp::Vector{Float64}
    amp_slope::Vector{Float64}
end
XXSolution(;nsteps = zero(UInt32), angle_sign = zero(Int32), time = Vector{Float64}(), phase = Vector{Float64}(), phase_slope = Vector{Float64}(), amp = Vector{Float64}(), amp_slope = Vector{Float64}()) = XXSolution(nsteps, angle_sign, time, phase, phase_slope, amp, amp_slope)
PB.default_values(::Type{XXSolution}) = (;nsteps = zero(UInt32), angle_sign = zero(Int32), time = Vector{Float64}(), phase = Vector{Float64}(), phase_slope = Vector{Float64}(), amp = Vector{Float64}(), amp_slope = Vector{Float64}())
PB.field_numbers(::Type{XXSolution}) = (;nsteps = 1, angle_sign = 2, time = 3, phase = 4, phase_slope = 5, amp = 6, amp_slope = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:XXSolution})
    nsteps = zero(UInt32)
    angle_sign = zero(Int32)
    time = PB.BufferedVector{Float64}()
    phase = PB.BufferedVector{Float64}()
    phase_slope = PB.BufferedVector{Float64}()
    amp = PB.BufferedVector{Float64}()
    amp_slope = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            nsteps = PB.decode(d, UInt32)
        elseif field_number == 2
            angle_sign = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, wire_type, time)
        elseif field_number == 4
            PB.decode!(d, wire_type, phase)
        elseif field_number == 5
            PB.decode!(d, wire_type, phase_slope)
        elseif field_number == 6
            PB.decode!(d, wire_type, amp)
        elseif field_number == 7
            PB.decode!(d, wire_type, amp_slope)
        else
            PB.skip(d, wire_type)
        end
    end
    return XXSolution(nsteps, angle_sign, time[], phase[], phase_slope[], amp[], amp_slope[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::XXSolution)
    initpos = position(e.io)
    x.nsteps != zero(UInt32) && PB.encode(e, 1, x.nsteps)
    x.angle_sign != zero(Int32) && PB.encode(e, 2, x.angle_sign)
    !isempty(x.time) && PB.encode(e, 3, x.time)
    !isempty(x.phase) && PB.encode(e, 4, x.phase)
    !isempty(x.phase_slope) && PB.encode(e, 5, x.phase_slope)
    !isempty(x.amp) && PB.encode(e, 6, x.amp)
    !isempty(x.amp_slope) && PB.encode(e, 7, x.amp_slope)
    return position(e.io) - initpos
end
function PB._encoded_size(x::XXSolution)
    encoded_size = 0
    x.nsteps != zero(UInt32) && (encoded_size += PB._encoded_size(x.nsteps, 1))
    x.angle_sign != zero(Int32) && (encoded_size += PB._encoded_size(x.angle_sign, 2))
    !isempty(x.time) && (encoded_size += PB._encoded_size(x.time, 3))
    !isempty(x.phase) && (encoded_size += PB._encoded_size(x.phase, 4))
    !isempty(x.phase_slope) && (encoded_size += PB._encoded_size(x.phase_slope, 5))
    !isempty(x.amp) && (encoded_size += PB._encoded_size(x.amp, 6))
    !isempty(x.amp_slope) && (encoded_size += PB._encoded_size(x.amp_slope, 7))
    return encoded_size
end

struct SysMetadata
    units::Dict{String,String}
    structure::String
end
SysMetadata(;units = Dict{String,String}(), structure = "") = SysMetadata(units, structure)
PB.default_values(::Type{SysMetadata}) = (;units = Dict{String,String}(), structure = "")
PB.field_numbers(::Type{SysMetadata}) = (;units = 1, structure = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SysMetadata})
    units = Dict{String,String}()
    structure = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, units)
        elseif field_number == 2
            structure = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return SysMetadata(units, structure)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SysMetadata)
    initpos = position(e.io)
    !isempty(x.units) && PB.encode(e, 1, x.units)
    !isempty(x.structure) && PB.encode(e, 2, x.structure)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SysMetadata)
    encoded_size = 0
    !isempty(x.units) && (encoded_size += PB._encoded_size(x.units, 1))
    !isempty(x.structure) && (encoded_size += PB._encoded_size(x.structure, 2))
    return encoded_size
end

struct Modes
    radial1::Vector{Float64}
    radial2::Vector{Float64}
    axial::Vector{Float64}
end
Modes(;radial1 = Vector{Float64}(), radial2 = Vector{Float64}(), axial = Vector{Float64}()) = Modes(radial1, radial2, axial)
PB.default_values(::Type{Modes}) = (;radial1 = Vector{Float64}(), radial2 = Vector{Float64}(), axial = Vector{Float64}())
PB.field_numbers(::Type{Modes}) = (;radial1 = 1, radial2 = 2, axial = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Modes})
    radial1 = PB.BufferedVector{Float64}()
    radial2 = PB.BufferedVector{Float64}()
    axial = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, radial1)
        elseif field_number == 2
            PB.decode!(d, wire_type, radial2)
        elseif field_number == 3
            PB.decode!(d, wire_type, axial)
        else
            PB.skip(d, wire_type)
        end
    end
    return Modes(radial1[], radial2[], axial[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Modes)
    initpos = position(e.io)
    !isempty(x.radial1) && PB.encode(e, 1, x.radial1)
    !isempty(x.radial2) && PB.encode(e, 2, x.radial2)
    !isempty(x.axial) && PB.encode(e, 3, x.axial)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Modes)
    encoded_size = 0
    !isempty(x.radial1) && (encoded_size += PB._encoded_size(x.radial1, 1))
    !isempty(x.radial2) && (encoded_size += PB._encoded_size(x.radial2, 2))
    !isempty(x.axial) && (encoded_size += PB._encoded_size(x.axial, 3))
    return encoded_size
end

struct SystemParams
    modes::Union{Nothing,Modes}
    lamb_dicke_parameters::Vector{Float64}
    participation_factors::Vector{ParticipationFactor}
    dac_terms::Dict{String,Float64}
    metadata::Union{Nothing,SysMetadata}
end
SystemParams(;modes = nothing, lamb_dicke_parameters = Vector{Float64}(), participation_factors = Vector{ParticipationFactor}(), dac_terms = Dict{String,Float64}(), metadata = nothing) = SystemParams(modes, lamb_dicke_parameters, participation_factors, dac_terms, metadata)
PB.default_values(::Type{SystemParams}) = (;modes = nothing, lamb_dicke_parameters = Vector{Float64}(), participation_factors = Vector{ParticipationFactor}(), dac_terms = Dict{String,Float64}(), metadata = nothing)
PB.field_numbers(::Type{SystemParams}) = (;modes = 1, lamb_dicke_parameters = 2, participation_factors = 3, dac_terms = 4, metadata = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SystemParams})
    modes = Ref{Union{Nothing,Modes}}(nothing)
    lamb_dicke_parameters = PB.BufferedVector{Float64}()
    participation_factors = PB.BufferedVector{ParticipationFactor}()
    dac_terms = Dict{String,Float64}()
    metadata = Ref{Union{Nothing,SysMetadata}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, modes)
        elseif field_number == 2
            PB.decode!(d, wire_type, lamb_dicke_parameters)
        elseif field_number == 3
            PB.decode!(d, participation_factors)
        elseif field_number == 4
            PB.decode!(d, dac_terms)
        elseif field_number == 5
            PB.decode!(d, metadata)
        else
            PB.skip(d, wire_type)
        end
    end
    return SystemParams(modes[], lamb_dicke_parameters[], participation_factors[], dac_terms, metadata[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SystemParams)
    initpos = position(e.io)
    !isnothing(x.modes) && PB.encode(e, 1, x.modes)
    !isempty(x.lamb_dicke_parameters) && PB.encode(e, 2, x.lamb_dicke_parameters)
    !isempty(x.participation_factors) && PB.encode(e, 3, x.participation_factors)
    !isempty(x.dac_terms) && PB.encode(e, 4, x.dac_terms)
    !isnothing(x.metadata) && PB.encode(e, 5, x.metadata)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SystemParams)
    encoded_size = 0
    !isnothing(x.modes) && (encoded_size += PB._encoded_size(x.modes, 1))
    !isempty(x.lamb_dicke_parameters) && (encoded_size += PB._encoded_size(x.lamb_dicke_parameters, 2))
    !isempty(x.participation_factors) && (encoded_size += PB._encoded_size(x.participation_factors, 3))
    !isempty(x.dac_terms) && (encoded_size += PB._encoded_size(x.dac_terms, 4))
    !isnothing(x.metadata) && (encoded_size += PB._encoded_size(x.metadata, 5))
    return encoded_size
end

struct GateSolutionSet
    params::Union{Nothing,SystemParams}
    XX::Dict{String,XXSolution}
end
GateSolutionSet(;params = nothing, XX = Dict{String,XXSolution}()) = GateSolutionSet(params, XX)
PB.default_values(::Type{GateSolutionSet}) = (;params = nothing, XX = Dict{String,XXSolution}())
PB.field_numbers(::Type{GateSolutionSet}) = (;params = 1, XX = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GateSolutionSet})
    params = Ref{Union{Nothing,SystemParams}}(nothing)
    XX = Dict{String,XXSolution}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, params)
        elseif field_number == 2
            PB.decode!(d, XX)
        else
            PB.skip(d, wire_type)
        end
    end
    return GateSolutionSet(params[], XX)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GateSolutionSet)
    initpos = position(e.io)
    !isnothing(x.params) && PB.encode(e, 1, x.params)
    !isempty(x.XX) && PB.encode(e, 2, x.XX)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GateSolutionSet)
    encoded_size = 0
    !isnothing(x.params) && (encoded_size += PB._encoded_size(x.params, 1))
    !isempty(x.XX) && (encoded_size += PB._encoded_size(x.XX, 2))
    return encoded_size
end
end # module
